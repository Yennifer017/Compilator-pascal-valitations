
package compi2.pascal.valitations.analysis;

import java_cup.runtime.*;
import java.util.*;


/*-----------------------------------------------------------
  CUP Specification for the Parser Class
  -----------------------------------------------------------*/
parser code {:
    //fields
    Lexer lex;
    private List<String> syntaxErrors;

    //conect the parser with the lexer
    public Parser(Lexer lex){
        super(lex);
        syntaxErrors = new LinkedList<>();
    }

    //getters
    public Lexer getLexer(){
        return this.lex;
    }
    public List<String> getSyntaxErrors(){
        return this.syntaxErrors;
    }
    
    /*SOBREESCRIBISEMICOLONO LOS METODOS DE ERROR*/
    public void syntax_error(Symbol cur_token) {
        String mss = "Simbolo: " + symbl_name_from_id(cur_token.sym)
                    + ", linea: " + cur_token.left
                    + ", columna: " + cur_token.right;
        if (expected_token_ids().isEmpty()) {
            mss += " -- ya no se esperaba ningun simbolo";
        }
        syntaxErrors.add(mss);
    }
    public void unrecovered_syntax_error(Symbol cur_token) {
        syntaxErrors.add("Errores de sintaxis severos detectados, revisa municiosamente el codigo");
    }
:}

/*---------------------------------------
             Declarations
-----------------------------------------*/
/* Terminals (tokens returned by the scanner). */
terminal            PLUS, MINUS, TIMES, BARRA,
                    LLAVE_L, LLAVE_R, PARENTESIS_L, PARENTESIS_R, CORCHETE_L, CORCHETE_R, ACENT,
                    EQUALS, DIFFERENT, GRATER, LESS, GRATER_EQUALS, LESS_EQUALS,
                    ASSIGNATION, COMA, DOT, SEMICOLON,
                    AND, ARRAY, BEGIN, CASE, CONST, DIV, DO,
                    DOWNTO, ELSE, SEMICOLON, FILE, FOR, FUNCTION, GOTO,
                    IF, IN, LABEL, MOD, NIL, NOT, OF,
                    OR, PACKED, PROCEDURE, PROGRAM, RECORD, REPEAT, SET,
                    THEN, TO, TYPE, UNTIL, VAR, WHILE, WITH,
                    INTEGER, REAL, BOOLEAN, CHAR, STRING,
                    ID, INTEGER_LIT, BOOLEAN_LIT, REAL_LIT, STRING_LIT, CHAR_LIT,
                    UMINUS
                    ;

/* Non-terminals */
non terminal        s, header,
                    var_type, integer_exp, id_list, literals,
                    type_b, type_dec, record_b,
                    const_b, const_dec, var_b, var_dec,
                    expression,
                    conditional, if_stmt, elif_stmt, else_stmt,
                    case_stmt,
                    while_stmt, for_stmt,
                    statements, block_stmt, stmt,
                    functions_b, functions, function_dec,
                    procedure_b, procedures, procedure_dec,
                    arguments, type_arg, main
                    ;

/*----------------------------------------
            Precedences 
-----------------------------------------*/

/*booleanos*/
precedence left THEN;
precedence left ELSE;
precedence left OR;
precedence left AND;
precedence left NOT;

/*relacionales*/
precedence left EQUALS, DIFFERENT, GRATER, GRATER_EQUALS, LESS, LESS_EQUALS;

/*operaciones*/
precedence left PLUS, MINUS;
precedence left DIV, MOD;
procedence left UMINUS;


/* --------------------------------------
            The grammar 
-----------------------------------------*/
start with s;
s ::=   header 
        types_b 
        const_b 
        var_b
        functions_b
        procedure_b
        main
        ;
        
header ::= PROGRAM ID ;

/*------------------- UTILITIES --------------------*/
var_type ::= INTEGER
            | REAL
            | BOOLEAN
            | CHAR
            | STRING
            | ID
            ;

integer_exp ::= INTEGER
            | ID
            ;

id_list ::= id_list COMA ID
            | ID
            ;

literals ::= BOOLEAN_LIT
            | INTEGER_LIT
            | REAL_LIT
            | CHAR_LIT
            | STRING_LIT
            ;

/*------------------- TYPES BLOCK --------------------*/
type_b ::= TYPE type_dec
            | /* empty */
            ;
type_dec ::=  id_list EQUALS var_type SEMICOLON
            | id_list EQUALS range SEMICOLON
            | id_list EQUALS ARRAY CORCHETE_L /*integer type*/ DOT DOT /*integer type*/ CORCHETE_R OF var_type SEMICOLON
            | id_list EQUALS RECORD record_b END SEMICOLON
            ;


record_b ::=
            ;


/*------------------- CONST BLOCK --------------------*/
const_b ::= CONST const_dec
            | /* empty */
            ;

const_dec ::= const_dec ID EQUALS literals SEMICOLON;


/*------------------- VARIABLES BLOCK --------------------*/
var_b ::= VAR var_dec
            ;
var_dec ::= id_list COLON var_type SEMICOLON
            | id_list COLON expression INTEGER_LIT DOT DOT INTEGER_LIT SEMICOLON
            | id_list COLON ARRAY CORCHETE_L INTEGER_LIT DOT DOT INTEGER_LIT CORCHETE_R OF var_type SEMICOLON
            | id_list EQUALS RECORD /*fiels*/ END SEMICOLON
            ;


/*-------------------- EXPRESSION BLOCK -------------------------*/

/**************************************
expression ::= expression AND expression
        | expression AND THEN expression
        | expression OR expression
        | expression OR ELSE expression
        | NOT expression
        | expression
        ;

bool ::= bool EQUALS bool
        | bool DIFFERENT bool
        | bool GRATER bool
        | bool LESS bool
        | bool GRATER_EQUALS bool
        | bool LESS_EQUALS bool
        | arit
        ;

arit ::= arit PLUS arit
        | arit MINUS arit
        | arit TIMES arit
        | arit DIV arit
        | arit MOD arit
        | single
        ;

single ::= ID vect
        | ID DOT ID
        | STRING_LIT
        | INTEGER_LIT
        | REAL_LIT
        | BOOLEAN_LIT
        | STRING_LIT
        ;
*****************************************/

e ::= e PLUS e
        | e MINUS e
        | e TIMES e
        | e DIV e
        | e MOD e
        | e AND e
        | e AND THEN e
        | e OR e
        | e OR ELSE e
        | e NOT e
        | e EQUALS e
        | e DIFFERENT e
        | e GRATER e
        | e GRATER_EQUALS e
        | e LESS e
        | e LESS_EQUALS e
        | ID vect
        | ID DOT ID
        | STRING_LIT
        | INTEGER_LIT
        | REAL_LIT
        | BOOLEAN_LIT
        | STRING_LIT
        ;

vect ::= CORCHETE_L expression CORCHETE_R
        | /*empty*/
        ;


/*-------------------- STATEMENTS BLOCK -------------------------*/

/************************* conditionals *****************************/

conditional ::= if_stm elif_stmt else_stmt
        ;
if_stmt ::= IF PARENTESIS_L expression PARENTESIS_R THEN statements
        ;

elif_stmt ::= elif_stmt ELSE IF PARENTESIS_L expression PARENTESIS_R THEN statements
        | ELSE IF PARENTESIS_L expression PARENTESIS_R THEN statements
        | /* empty */
        ;

else_stmt ::= ELSE statements
        | /* empty */
        ;

/************************* case *****************************/

case_stmt ::= CASE PARENTESIS_L expression PARENTESIS_R OF  /*HEREEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE*/
        ;

/************************* ciclos *****************************/

while_stmt ::= WHILE PARENTESIS_L expression PARENTESIS_R DO statements
        ;

for_stmt ::= FOR expression ASSIGNATION expression TO expression DO statements
        ;

/************************* statements *****************************/
statements ::= stmt
        | stmt SEMICOLON
        | BEGIN block_stmt END SEMICOLON
        ;

block_stmt ::= block_stmt stmt SEMICOLON
        | stmt SEMICOLON
        | /* empty */
        ;

stmt ::= conditional
        | case_stmt
        | while_stmt
        | for_stmt
        | BREAK
        | CONTINUE
        | ID ASSIGNATION expression
        | assign_stmt  /*HEREEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE*/
        ;

/*-------------------- FUNCTIONS -------------------------*/

functions_b ::= functions
        | /* empty */
        ;

functions ::= functions function_dec
        ;

function_dec ::= function_dec FUNCTION ID PARENTESIS_L arguments PARENTESIS_R COLON var_type SEMICOLON
            var_b
            BEGIN block_stmt END SEMICOLON
        ;

/*-------------------- PROCEDURES -------------------------*/

procedure_b ::= procedures
        | /* empty */
        ;

procedures ::= procedures procedure_dec
        | procedure_dec
        ;

procedure_dec ::= PROCEDURE ID PARENTESIS_L arguments PARENTESIS_R SEMICOLON
            var_b
            BEGIN block_stmt END SEMICOLON
        ;

/*-------------------- PARAMS -------------------------*/
arguments ::= args COMA type_arg
        | type_arg
        | /* empty */
        ;

type_arg ::= VAR id_list COLON var_type
        | id_list COLON var_type
        ;

/*-------------------- MAIN SECTION -------------------------*/
main ::= BEGIN block_stmt END DOT
        ;


/*-------------------- OTHERS -------------------------*/
