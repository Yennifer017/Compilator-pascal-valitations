
package compi2.pascal.valitations.analysis;

import java_cup.runtime.*;
import java.util.*;

import java_cup.runtime.*;
import java.util.*;
import compi2.pascal.valitations.analysis.typet.*;
import compi2.pascal.valitations.analyzator.GenTypeTab;
import compi2.pascal.valitations.semantic.expr.*;
import compi2.pascal.valitations.semantic.obj.*;
import compi2.pascal.valitations.util.Position;


/*-----------------------------------------------------------
  CUP Specification for the Parser Class
  -----------------------------------------------------------*/
parser code {:
    //fields
    Lexer lex;
    private List<String> syntaxErrors;
    private GenTypeTab genTypeTab;

    //conect the parser with the lexer
    public Parser(Lexer lex){
        super(lex);
        syntaxErrors = new LinkedList<>();
        genTypeTab = new GenTypeTab();
    }

    //getters
    public Lexer getLexer(){
        return this.lex;
    }
    public List<String> getSyntaxErrors(){
        return this.syntaxErrors;
    }
    
    /*SOBREESCRIBIR LOS METODOS DE ERROR*/
    public void syntax_error(Symbol cur_token) {
        String mss = "Simbolo: " + symbl_name_from_id(cur_token.sym)
                    + ", linea: " + cur_token.left
                    + ", columna: " + cur_token.right;
        if (expected_token_ids().isEmpty()) {
            mss += " -- ya no se esperaba ningun simbolo";
        }
        syntaxErrors.add(mss);
    }
    public void unrecovered_syntax_error(Symbol cur_token) {
        syntaxErrors.add("Errores de sintaxis severos detectados, revisa municiosamente el codigo");
    }
:}

/*---------------------------------------
             Declarations
-----------------------------------------*/
/* Terminals (tokens returned by the scanner). */
terminal            PLUS, MINUS, TIMES, BARRA,
                    LLAVE_L, LLAVE_R, PARENTESIS_L, PARENTESIS_R, CORCHETE_L, CORCHETE_R, ACENT,
                    EQUALS, DIFFERENT, GRATER, LESS, GRATER_EQUALS, LESS_EQUALS,
                    ASSIGNATION, COMA, DOT, SEMICOLON, COLON,
                    AND, ARRAY, BEGIN, CASE, CONST, DIV, DO,
                    DOWNTO, ELSE, END, FILE, FOR, FUNCTION, GOTO,
                    IF, IN, LABEL, MOD, NIL, NOT, OF,
                    OR, PACKED, PROCEDURE, PROGRAM, RECORD, REPEAT, SET,
                    THEN, TO, TYPE, UNTIL, VAR, WHILE, WITH,
                    INTEGER, REAL, BOOLEAN, CHAR, STRING, LONGINT,
                    INTEGER_LIT, BOOLEAN_LIT, REAL_LIT, STRING_LIT, CHAR_LIT,
                    WRITELN, READLN, RETURN, BREAK, CONTINUE,
                    UMINUS, COND
                    ;
terminal String     ID;

/* Non-terminals */
non terminal        s, header,
                    record_b,
                    const_b, const_dec,
                    var_b, var_dec,
                    conditional, if_stmt, elif_stmt, else_stmt, pos_if, pos_elif, statements_wc,
                    case_stmt, case_block, labels, single_stm,
                    while_stmt, for_stmt, repeat_stmt,
                    statements, block_stmt, stmt,
                    functions_b, functions, function_dec,
                    procedure_b, procedures, procedure_dec,
                    arguments, type_arg,
                    main,
                    definite_fun, writefn, readfn,
                    list_stmts, more_stmts,
                    simple_stmt, complex_stmt, single_stmt, list_vardec,
                    def_record,more_records, list_constdec
                    ;

non terminal List<Label> id_list, list_access
                    ;
non terminal Label var_type
                    ;
non terminal List<TypeDefAst> type_b, list_typedec, type_dec
                    ;
non terminal Expression expression, bool_exp, arit_exp, literals
                    ;
non terminal List<Expression> expression_list
                    ;
non terminal Range range, arr_range
                    ;

/*----------------------------------------
            Precedences
-----------------------------------------*/

/*booleanos*/
precedence left THEN;
precedence left ELSE;
precedence left OR;
precedence left AND;
precedence left NOT;

/*operaciones*/
precedence left PLUS, MINUS;
precedence left TIMES, DIV, BARRA, MOD;
precedence right UMINUS;

precedence right SEMICOLON;
precedence right DOT;

/* --------------------------------------
            The grammar 
-----------------------------------------*/
start with s;
s ::=   header 
        type_b:lt
        const_b 
        var_b
        functions_b
        procedure_b
        main
        {:
            TypeTable typeTable = genTypeTab.generateTable(true, lt);
        :}
        ;
        
header ::= PROGRAM ID SEMICOLON;

/*-------------------------------------- UTILITIES --------------------------------*/
var_type ::= INTEGER:t  
                    {: 
                        RESULT = new Label(
                            PrimitiveType.IntegerPT.getName(), 
                            new Position(tleft, tright)
                        ); 
                    :}
            | REAL:t    
                    {: 
                        RESULT = new Label(
                            PrimitiveType.RealPT.getName(), 
                            new Position(tleft, tright)
                        ); 
                    :}
            | LONGINT:t
                    {:
                        RESULT = new Label(
                            PrimitiveType.LongintPT.getName(), 
                            new Position(tleft, tright)
                        ); 
                    :}
            | BOOLEAN:t 
                    {: 
                        RESULT = new Label(
                            PrimitiveType.BooleanPT.getName(), 
                            new Position(tleft, tright)
                        ); 
                    :}
            | CHAR:t    
                    {: 
                        RESULT = new Label(
                            PrimitiveType.CharPT.getName(), 
                            new Position(tleft, tright)
                        ); 
                    :}
            | STRING:t  
                    {: 
                        RESULT = new Label(
                            PrimitiveType.StringPT.getName(), 
                            new Position(tleft, tright)
                        ); 
                    :}
            | ID:t  
                    {: 
                        RESULT = new Label(
                            t, 
                            new Position(tleft, tright)
                        ); 
                    :}
            ;

id_list ::= id_list:l COMA ID:i
                    {:
                        l.add(new Label(i, new Position(ileft, iright)));
                        RESULT = l;
                    :}

            | ID:i      
                    {:
                        List<Label> list = new ArrayList<>();
                        list.add(new Label(i, new Position(ileft, iright)));
                        RESULT = list;
                    :}
            ;

range ::= expression:e1 DOT DOT DOT expression:e2
                    {:
                        RESULT = new Range(e1, e2);
                    :}
            ;

arr_range ::= CORCHETE_L expression:e1 DOT DOT expression:e2 CORCHETE_R
                    {:
                         RESULT = new Range(e1, e2);
                    :}
            ;

record_b ::= def_record more_records
            ;

def_record ::= ID COLON var_type SEMICOLON
            | ID COLON PACKED ARRAY arr_range OF var_type SEMICOLON
            ;

more_records ::= def_record more_records
            | /* empty */
            ;


expression_list ::= expression_list:l COMA expression:e
                    {:
                        l.add(e);
                        RESULT = l;
                    :}
            | expression:e
                    {:
                        LinkedList<Expression> list = new LinkedList<Expression>();
                        list.add(e);
                        RESULT = list;
                    :}
            ;

/*---------------------------------- TYPES BLOCK -------------------------------------*/
type_b ::= TYPE list_typedec:l
                    {:
                        RESULT = l;
                    :}
            | /* empty */
                    {:
                        RESULT = new ArrayList<TypeDefAst>();
                    :}
            ;

list_typedec ::= type_dec:l1 list_typedec:l2
                    {:
                        l1.addAll(l2);
                        RESULT = l1;
                    :}
            | type_dec:l
                    {:
                        RESULT = l;
                    :}
            ;

type_dec ::=  id_list:l EQUALS var_type:t SEMICOLON 
                    {:
                        RESULT = genTypeTab.userDef(l, t);
                    :}
            | id_list:l EQUALS range:r SEMICOLON
                    {:
                        RESULT = genTypeTab.rangeDef(l, r);
                    :}
            | id_list:l EQUALS ARRAY arr_range:r OF var_type:t SEMICOLON
                    {:
                        RESULT = genTypeTab.arrayDef(l, r, t);
                    :}
            | id_list:l EQUALS RECORD record_b END SEMICOLON 
            ;


/*-------------------------------------- CONST BLOCK ---------------------------------*/
const_b ::= CONST list_constdec
            | /* empty */
            ;

list_constdec ::= const_dec list_constdec
            | const_dec
            ;

const_dec ::= const_dec ID EQUALS expression SEMICOLON
            ;


/*-------------------------------------- VARIABLES BLOCK -------------------------------*/
var_b ::= VAR list_vardec
            | /* emtpy */
            ;

list_vardec ::= list_vardec var_dec
            | var_dec
            ;

var_dec ::= id_list COLON var_type SEMICOLON
            | id_list COLON range SEMICOLON
            | id_list COLON ARRAY arr_range OF var_type SEMICOLON
            | id_list EQUALS RECORD record_b END SEMICOLON
            ;


/*---------------------------------- EXPRESSION BLOCK -------------------------------------*/

expression ::= expression:e1 AND:o expression:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.And, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | expression:e1 AND:o THEN expression:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.AndThen, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | expression:e1 OR:o expression:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Or, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | expression:e1 OR:o ELSE expression:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.OrElse, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            %prec UMINUS
            | NOT:o expression:e
                    {:
                        RESULT = new UnaryOperation(
                            DefiniteOperation.Not,
                            e,
                            new Position(oleft, oright)
                        );
                    :}
            | bool_exp:e
                    {:
                        RESULT = e;
                    :}
            ;

bool_exp ::= arit_exp:e1 EQUALS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.EqualsTo, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 DIFFERENT:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.DifferentTo, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 GRATER:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.GraterThan, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 LESS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.LessThan, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 GRATER_EQUALS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.GraterEq, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 LESS_EQUALS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.LessEq, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e
                    {:
                        RESULT = e;
                    :}
            ;

arit_exp ::= arit_exp:e1 PLUS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Addition, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 MINUS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Substraction, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 TIMES:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Multiplication, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 DIV:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.IntDivision, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 BARRA:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Division, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 MOD:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Module, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | literals:e
                    {:
                        RESULT = e;
                    :}
            | ID:i CORCHETE_L arit_exp:e CORCHETE_R
                    {:
                        RESULT = new VectorUse(
                            i, e, new Position(ileft, iright)
                        );
                    :}
            | ID:i DOT list_access:l
                    {:
                        l.add(0, new Label(i, new Position(ileft, iright)));
                        RESULT = new RecordUse(l);
                    :}
            | ID:i PARENTESIS_L expression_list:l PARENTESIS_R
                    {:
                        RESULT = new FunctionUse(
                            i, l, new Position(ileft, iright)
                        );
                    :}
            | ID:i
                    {:
                        RESULT = new SingleExp(
                            i, new Position(ileft,iright)
                        );
                    :}
            %prec UMINUS
            | PARENTESIS_L expression:e PARENTESIS_R
                    {:
                        RESULT = e;
                    :}
            %prec UMINUS
            | PLUS:o arit_exp:e
                    {:
                        RESULT = new UnaryOperation(
                            DefiniteOperation.Addition,
                            e,
                            new Position(oleft, oright)
                        );
                    :}
            %prec UMINUS
            | MINUS:o arit_exp:e
                    {:
                        RESULT = new UnaryOperation(
                            DefiniteOperation.Substraction,
                            e,
                            new Position(oleft, oright)
                        );
                    :}
            ;

list_access ::=  list_access:l DOT ID:i 
                    {:
                        l.add(new Label(i, new Position(ileft, iright)));
                        RESULT = l;
                    :}
            | ID:i
                    {:
                        ArrayList<Label> access = new ArrayList<>();
                        access.add(new Label(i, new Position(ileft, iright)));
                        RESULT = access;
                    :}
            ;

literals ::= BOOLEAN_LIT:l
                    {:
                        RESULT = new SingleExp(
                            PrimitiveType.BooleanPT, 
                            new Position(lleft, lright)
                        );
                    :}
            | INTEGER_LIT:l
                    {:
                        RESULT = new SingleExp(
                            PrimitiveType.IntegerPT, 
                            new Position(lleft, lright)
                        );
                    :}
            | REAL_LIT:l
                    {:
                        RESULT = new SingleExp(
                            PrimitiveType.RealPT, 
                            new Position(lleft, lright)
                        );
                    :}
            | CHAR_LIT:l
                    {:
                        RESULT = new SingleExp(
                            PrimitiveType.CharPT, 
                            new Position(lleft, lright)
                        );
                    :}
            | STRING_LIT:l
                    {:
                        RESULT = new SingleExp(
                            PrimitiveType.StringPT, 
                            new Position(lleft, lright)
                        );
                    :}
            ;


/*------------------------------------------- STATEMENTS BLOCK ------------------------------*/

/************************* conditionals *****************************/

conditional ::= if_stmt pos_if
        ;
if_stmt ::= IF PARENTESIS_L expression PARENTESIS_R THEN
        ;

pos_if ::= simple_stmt elif_stmt
        | simple_stmt SEMICOLON
        | complex_stmt
        | BEGIN block_stmt END SEMICOLON
        | BEGIN block_stmt END elif_stmt
        ;

elif_stmt ::= elif_stmt ELSE IF PARENTESIS_L expression PARENTESIS_R THEN pos_elif
        | ELSE IF PARENTESIS_L expression PARENTESIS_R THEN pos_elif
        | else_stmt
        ;

pos_elif ::= simple_stmt else_stmt
        | simple_stmt SEMICOLON
        | BEGIN block_stmt END SEMICOLON
        | BEGIN block_stmt END else_stmt
        ;

else_stmt ::= ELSE statements_wc
        | /* empty */
        ;

statements_wc ::= simple_stmt SEMICOLON
        | BEGIN block_stmt END SEMICOLON
        ;

/************************* case *****************************/

case_stmt ::= CASE PARENTESIS_L expression PARENTESIS_R OF case_block ELSE single_stm END SEMICOLON
        ;

case_block ::= labels COLON single_stm SEMICOLON
        ;

labels ::= labels COMA expression
        | expression
        ;

single_stm ::= ID ASSIGNATION expression
        | ID PARENTESIS_L expression_list PARENTESIS_R
        | ID DOT ID
        | definite_fun
        ;

/************************* ciclos *****************************/

while_stmt ::= WHILE PARENTESIS_L expression PARENTESIS_R DO statements
        ;

for_stmt ::= FOR ID ASSIGNATION expression TO expression DO statements
        ;

repeat_stmt ::= REPEAT statements UNTIL expression SEMICOLON
        ;

/************************* statements *****************************/
statements ::= simple_stmt
        | simple_stmt SEMICOLON
        | complex_stmt
        | BEGIN block_stmt END SEMICOLON
        ;

block_stmt ::= list_stmts
        | /* empty */
        ;

list_stmts ::= simple_stmt
        | simple_stmt SEMICOLON
        | complex_stmt
        | simple_stmt SEMICOLON more_stmts
        | complex_stmt more_stmts
        ;

more_stmts ::= simple_stmt
        | simple_stmt SEMICOLON
        | simple_stmt SEMICOLON more_stmts
        | complex_stmt more_stmts
        | complex_stmt
        ;

simple_stmt ::= BREAK
        | CONTINUE
        | ID ASSIGNATION expression
        | ID PARENTESIS_L expression_list PARENTESIS_R
        | ID DOT ID ASSIGNATION expression
        | definite_fun
        ; 

complex_stmt ::= conditional
        | case_stmt
        | while_stmt
        | for_stmt
        | repeat_stmt
        ;

/*-------------------- FUNCTIONS -------------------------*/

functions_b ::= functions
        | /* empty */
        ;

functions ::= functions function_dec
        ;

function_dec ::= function_dec FUNCTION ID PARENTESIS_L arguments PARENTESIS_R COLON var_type SEMICOLON
            var_b
            BEGIN block_stmt END SEMICOLON
        ;

/*-------------------------------------- PROCEDURES ----------------------------------*/

procedure_b ::= procedures
        | /* empty */
        ;

procedures ::= procedures procedure_dec
        | procedure_dec
        ;

procedure_dec ::= PROCEDURE ID PARENTESIS_L arguments PARENTESIS_R SEMICOLON
            var_b
            BEGIN block_stmt END SEMICOLON
        ;

/*---------------------------------- PARAMS / ARGUMENTS ----------------------------------*/
arguments ::= arguments COMA type_arg
        | type_arg
        | /* empty */
        ;

type_arg ::= VAR id_list COLON var_type
        | id_list COLON var_type
        ;

/*----------------------------------- MAIN SECTION -------------------------------------*/
main ::= BEGIN block_stmt END DOT
        ;

/*---------------------------------------- OTHERS ---------------------------------------*/
definite_fun ::= writefn
        | readfn
        ;

writefn ::= WRITELN PARENTESIS_L expression_list PARENTESIS_R
        ;
readfn ::= READLN PARENTESIS_L expression_list PARENTESIS_R
        ;
